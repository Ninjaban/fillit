short tetri; -> truc binaire
'.' = 0;
'#' = 1;

....
.##.
.##.
....

l = 0;
c = 0;

while (somme tetri << 0-4 == 0) -> tetri = tetri << 4;

.##.
.##.
....
....

while (somme tetri << (n % 4 == 0) == 0) -> tetri << !(n % 4 == 3) = tetri << (n + 1) ; tetri << (n % 4 == 3) = 0 ;

##..  .#.. .#.. .##. .#.. ..#. .#..
##..  ###. ##.. ##.. ##.. ###. .#..
....  .... .#.. .... #... .... ##..
....  .... .... .... .... .... ....

----- sujet

nb tetrimino max = 26
taille d'un tetrimino = 16 (4 * 4) -> short

objectif : trouver le plus petit carre
Assigner une lettre de l'alphabet en majuscule dans l'ordre du fichier

pas de rotation

backtracking

----- theory

a square of length n will (at best) fit (n ^ 2) / 4 Tetrominoes

taille min de la map = sqrt(4 * nb tetrominoes);

taille min 26 pieces = 11;
taille max de la map = 16 * 26 = 416 -> 441 (21 * 21); // ne devrait jamais etre atteint

map en binaire (char * ?) (bit fields ?)

typedef struct s_mapl {
		type	[name] : width ;
		unsigned int   field : 21;
}			   t_mapl;

Pour une case libre, placer la piece de telle sorte que la case soit occupee

----- test placement valide :

taille map : n * n
position : p
ligne : l

verifier placement possible selon dimensions de la piece (limites gauche et bas)
si 1ere case vide, decaler test de 1 (sauf limite droite) (piece < 0x8000)

l = 0
while (l < 4 && DANS LA MAP && nb'#' < 4)
{
	res += (map4*4 (p + (n * l)) & piece (4 * l)); -> comparer 4 bits uniquement
	l++;
}
if (res == 0)
	OK;
else
	NG;

----- structure

struct piece
{
	char	letter;
	int		pos; (-1 | <= 0)
}

struct map
{
	?				map;
	// unsigned int *map ?
	unsigned int	size;
}

----- operateurs binaires

& AND	   0011 & 1010 = 0010
| OR	   0011 | 1010 = 1011
^ XOR	   0011 ^ 1010 = 1001
<<		   decalage a gauche	x << 1 = 2 * x
>>		   decalage a droite	x >> 1 = x / 2
~		   complementaire par bit : ~(0011) == 1100


forcer a 1 :
unsigned char b = a | (1 << n);

forcer a 0 :
unsigned char b = a & ~(1 << n);

inverser :
unsigned char b = a ^ (1 << n);

tester :
unsigned char b = a & (1 << n);

donner valeur au n-ieme bit de s
1: s |= (1 << n);
0: s &= ~(1 << n);

copier :
{
	read_from = 3;  // read bit 3
	write_to = 5;   // write to bit 5

	the_bit = ((byte1 >> read_from) & 1) << write_to;
	byte2 &= ~(1 << write_to);
	byte2 |= the_bit;
}

copier n bits
{
	u_short calc(u_int src, u_short dest, int pa, int pb, int n)
	{
		u_int mask;

    	mask = ((1 << (n)) - 1) << (pa - n);
    	return (((~src & mask) >> (pa - n) << pb) ^ (dest | (mask >> (pa - n) << pb)));
	}
} // copie n bits a la position pa de src vers la position pb de dest

copier les bits positifs
return (dest | (((~src & mask) >> (pa - n) << pb) ^ (dest | (mask >> (pa - n) << pb))));

if (XOR == OR) (& == 0) -> pas d'intersection -> placement OK

placement position p :
map |= map & (piece << p);

---- capacity

unsigned int	0xFFFFFFFF
unsigned short	0xFFFF

----- binary to hexadecimal

0000 <-> 0
0001 <-> 1
0010 <-> 2
0011 <-> 3
0100 <-> 4
0101 <-> 5
0110 <-> 6
0111 <-> 7
1000 <-> 8
1001 <-> 9
1010 <-> A
1011 <-> B
1100 <-> C
1101 <-> D
1110 <-> E
1111 <-> F

----- notes

sizeof() -> returns size in bytes
1 byte = 8 bits
